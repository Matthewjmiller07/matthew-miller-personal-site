---
// src/pages/torah-schedule.astro
import Layout from '../layouts/Layout.astro';

// Import Hebcal for server-side rendering (SSR)
// This won't be available on the client side directly
// but we'll use it for initial rendering if needed
import * as Hebcal from '@hebcal/core';
---

<Layout title="Torah Study Schedule Generator">
    <!-- Client-side script to load Hebcal properly -->
    <script>
        // This will be executed in the browser
        // We need to import Hebcal dynamically for client-side use
        import('@hebcal/core').then(module => {
            // Store the module in a global variable for easy access
            window.HebcalModule = module;
            console.log('Hebcal library loaded successfully via ESM import');
        }).catch(error => {
            console.error('Failed to load Hebcal library:', error);
        });
    </script>
    <div class="torah-scheduler">
        <div class="container">
            <h1>Torah Study Schedule Generator</h1>
            <p>Generate a personalized 5-year Torah study schedule from Hebrew age 5 to 10</p>
            
            <form id="scheduleForm" class="form">
                <div class="form-group">
                    <label for="childName">Child's Name:</label>
                    <input 
                        type="text" 
                        id="childName" 
                        name="childName" 
                        required 
                        placeholder="Enter child's name"
                    />
                </div>
                
                <div class="form-group">
                    <label for="birthDate">Birth Date:</label>
                    <input 
                        type="date" 
                        id="birthDate" 
                        name="birthDate" 
                        required 
                    />
                </div>
                
                <button type="submit" id="generateBtn">Generate Schedule</button>
            </form>
            
            <div id="progressContainer" class="progress-container hidden">
                <div class="progress-bar">
                    <div id="progressBar" class="progress-fill"></div>
                </div>
                <div id="progressText" class="progress-text">Initializing...</div>
            </div>
            
            <div id="results" class="results hidden">
                <h2>Schedule Generated Successfully!</h2>
                <div class="download-buttons">
                    <button id="downloadCSV" class="download-btn">Download CSV</button>
                    <button id="downloadLaTeX" class="download-btn">Download LaTeX</button>
                    <button id="downloadICS" class="download-btn">Download Calendar (ICS)</button>
                </div>
                <div id="preview" class="preview"></div>
            </div>
        </div>
    </div>
</Layout>

<style>
    /* Dark theme variables */
    :root {
        --bg-primary: #0f0f23;
        --bg-secondary: #1a1a2e;
        --bg-tertiary: #16213e;
        --text-primary: #e6e6fa;
        --text-secondary: #9ca3af;
        --accent-primary: #4f46e5;
        --accent-secondary: #6366f1;
        --border-color: #374151;
        --shadow-color: rgba(0, 0, 0, 0.3);
        --success-bg: #065f46;
        --success-border: #059669;
        --error-bg: #7f1d1d;
        --error-border: #dc2626;
        --error-text: #fca5a5;
    }

    body {
        background: var(--bg-primary);
        color: var(--text-primary);
        min-height: 100vh;
    }

    .torah-scheduler {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
        font-family: system-ui, sans-serif;
    }
    
    .container {
        background: var(--bg-secondary);
        border-radius: 12px;
        padding: 2rem;
        box-shadow: 0 4px 6px var(--shadow-color);
        border: 1px solid var(--border-color);
    }
    
    h1 {
        color: var(--accent-secondary);
        margin-bottom: 0.5rem;
        text-align: center;
    }
    
    h2 {
        color: var(--text-primary);
    }
    
    p {
        text-align: center;
        color: var(--text-secondary);
        margin-bottom: 2rem;
    }
    
    .form {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }
    
    .form-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    label {
        font-weight: 600;
        color: var(--text-primary);
    }
    
    input {
        padding: 0.75rem;
        border: 2px solid var(--border-color);
        border-radius: 6px;
        font-size: 1rem;
        transition: border-color 0.2s;
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }
    
    input:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    input::placeholder {
        color: var(--text-secondary);
    }
    
    small {
        color: var(--text-secondary);
        font-size: 0.875rem;
    }
    
    button {
        padding: 1rem 2rem;
        background: var(--accent-primary);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    button:hover {
        background: var(--accent-secondary);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px var(--shadow-color);
    }
    
    button:disabled {
        background: #4b5563;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }
    
    .progress-container {
        margin: 2rem 0;
        padding: 1rem;
        background: var(--bg-tertiary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
    }
    
    .progress-bar {
        width: 100%;
        height: 12px;
        background: var(--border-color);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 0.5rem;
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
        width: 0%;
        transition: width 0.3s ease;
    }
    
    .progress-text {
        text-align: center;
        color: var(--text-primary);
        font-weight: 500;
    }
    
    .results {
        margin-top: 2rem;
        padding: 1rem;
        background: var(--success-bg);
        border-radius: 8px;
        border: 2px solid var(--success-border);
    }
    
    .download-buttons {
        display: flex;
        gap: 1rem;
        margin: 1rem 0;
        flex-wrap: wrap;
    }
    
    .download-btn {
        background: var(--success-border);
        flex: 1;
        min-width: 150px;
    }
    
    .download-btn:hover {
        background: #047857;
    }
    
    .preview {
        margin-top: 1rem;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: 6px;
        max-height: 300px;
        overflow-y: auto;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.875rem;
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        white-space: pre-wrap;
    }
    
    .preview::-webkit-scrollbar {
        width: 8px;
    }
    
    .preview::-webkit-scrollbar-track {
        background: var(--bg-tertiary);
    }
    
    .preview::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 4px;
    }
    
    .preview::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary);
    }
    
    .hidden {
        display: none;
    }
    
    .error {
        color: var(--error-text);
        background: var(--error-bg);
        border: 1px solid var(--error-border);
        padding: 1rem;
        border-radius: 6px;
        margin: 1rem 0;
    }

    /* Hebrew text support */
    .hebrew-text {
        direction: rtl;
        font-family: 'SBL Hebrew', 'Ezra SIL', 'Times New Roman', serif;
    }

    /* Responsive design */
    @media (max-width: 768px) {
        .torah-scheduler {
            padding: 1rem;
        }
        
        .container {
            padding: 1.5rem;
        }
        
        .download-buttons {
            flex-direction: column;
        }
        
        .download-btn {
            min-width: auto;
        }
    }

    /* Focus indicators for accessibility */
    button:focus-visible {
        outline: 2px solid var(--accent-secondary);
        outline-offset: 2px;
    }

    /* Smooth transitions */
    * {
        transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
</style>

<script>
    // Initialize when the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Check if Hebcal module is available
        if (window.HebcalModule) {
            console.log('Hebcal library already loaded via ESM import');
        } else {
            console.log('Waiting for Hebcal library to load...');
            // We'll check again when trying to use it
        }
    });
    
    // Fallback Hebrew date calculator in case Hebcal fails
    class HebrewDateCalculator {
        constructor() {
            // Hebrew months (approximation)
            this.hebrewMonths = {
                1: 'Nisan', 2: 'Iyar', 3: 'Sivan', 4: 'Tammuz', 5: 'Av', 6: 'Elul',
                7: 'Tishrei', 8: 'Cheshvan', 9: 'Kislev', 10: 'Tevet', 11: 'Shevat', 12: 'Adar', 13: 'Adar II'
            };
            
            // Hebrew months in Hebrew
            this.hebrewMonthsHebrew = {
                1: 'ניסן', 2: 'אייר', 3: 'סיון', 4: 'תמוז', 5: 'אב', 6: 'אלול',
                7: 'תשרי', 8: 'חשון', 9: 'כסלו', 10: 'טבת', 11: 'שבט', 12: 'אדר', 13: 'אדר ב'
            };
            
            // Days of week in Hebrew
            this.hebrewDaysOfWeek = {
                'Sunday': 'יום ראשון', 'Monday': 'יום שני', 'Tuesday': 'יום שלישי',
                'Wednesday': 'יום רביעי', 'Thursday': 'יום חמישי', 'Friday': 'יום שישי',
                'Saturday': 'שבת'
            };
        }
        
        // Approximate conversion from Gregorian to Hebrew date
        // This is a simplified approximation - not accurate for all dates
        gregorianToHebrew(date) {
            const gregorianYear = date.getFullYear();
            const gregorianMonth = date.getMonth() + 1; // JS months are 0-indexed
            const gregorianDay = date.getDate();
            
            // Approximate Hebrew year (usually Gregorian year + 3760)
            let hebrewYear = gregorianYear + 3760;
            
            // Adjust for Jewish New Year (Rosh Hashanah) which is typically in September
            if (gregorianMonth >= 9 && gregorianDay >= 15) {
                hebrewYear = gregorianYear + 3761;
            }
            
            // Approximate Hebrew month (this is a rough mapping)
            // In reality, the Hebrew calendar is lunisolar and months don't align perfectly
            let hebrewMonth;
            if (gregorianMonth === 1) hebrewMonth = 10; // January ~ Tevet/Shevat
            else if (gregorianMonth === 2) hebrewMonth = 11; // February ~ Shevat/Adar
            else if (gregorianMonth === 3) hebrewMonth = 12; // March ~ Adar/Nisan
            else if (gregorianMonth === 4) hebrewMonth = 1; // April ~ Nisan/Iyar
            else if (gregorianMonth === 5) hebrewMonth = 2; // May ~ Iyar/Sivan
            else if (gregorianMonth === 6) hebrewMonth = 3; // June ~ Sivan/Tammuz
            else if (gregorianMonth === 7) hebrewMonth = 4; // July ~ Tammuz/Av
            else if (gregorianMonth === 8) hebrewMonth = 5; // August ~ Av/Elul
            else if (gregorianMonth === 9) hebrewMonth = 6; // September ~ Elul/Tishrei
            else if (gregorianMonth === 10) hebrewMonth = 7; // October ~ Tishrei/Cheshvan
            else if (gregorianMonth === 11) hebrewMonth = 8; // November ~ Cheshvan/Kislev
            else if (gregorianMonth === 12) hebrewMonth = 9; // December ~ Kislev/Tevet
            
            // Approximate Hebrew day (simplified)
            // In reality, Hebrew days start at sunset of the previous day
            let hebrewDay = gregorianDay;
            
            return {
                year: hebrewYear,
                month: hebrewMonth,
                day: hebrewDay,
                monthName: this.hebrewMonths[hebrewMonth],
                monthNameHebrew: this.hebrewMonthsHebrew[hebrewMonth]
            };
        }
        
        // Format a Hebrew date as a string
        formatHebrewDate(hebrewDate) {
            return `${hebrewDate.day} ${hebrewDate.monthNameHebrew} ${hebrewDate.year}`;
        }
        
        // Calculate Hebrew birthday for a specific year
        calculateHebrewBirthday(birthDate, targetHebrewYear) {
            const hebrewBirthDate = this.gregorianToHebrew(birthDate);
            
            // Create a new date starting from the previous Gregorian year
            // and search forward to find the Hebrew birthday
            const targetGregorianYear = targetHebrewYear - 3761;
            let approximateDate = new Date(targetGregorianYear, 0, 1); // January 1st
            
            // Search for up to 2 years (to handle edge cases)
            for (let i = 0; i < 730; i++) {
                const currentHebrewDate = this.gregorianToHebrew(approximateDate);
                
                // Check if this is the Hebrew birthday in the target year
                if (currentHebrewDate.year === targetHebrewYear && 
                    currentHebrewDate.month === hebrewBirthDate.month && 
                    currentHebrewDate.day === hebrewBirthDate.day) {
                    return approximateDate;
                }
                
                // Move to next day
                approximateDate.setDate(approximateDate.getDate() + 1);
            }
            
            // Fallback: return approximate date based on Gregorian birthday
            const fallbackDate = new Date(birthDate);
            fallbackDate.setFullYear(targetGregorianYear);
            return fallbackDate;
        }
    }
    
    // Initialize the Hebrew date calculator
    const hebrewCalculator = new HebrewDateCalculator();
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Initialized simplified Hebrew date calculator');
    });
    class TorahScheduleGenerator {
        constructor() {
            this.hebrewMonthNames = {
                1: 'ניסן', 2: 'אייר', 3: 'סיון', 4: 'תמוז', 5: 'אב', 6: 'אלול',
                7: 'תשרי', 8: 'חשון', 9: 'כסלו', 10: 'טבת', 11: 'שבט', 12: 'אדר', 13: 'אדר ב׳'
            };

            this.hebrewDays = {
                'Sunday': 'יום ראשון', 'Monday': 'יום שני', 'Tuesday': 'יום שלישי',
                'Wednesday': 'יום רביעי', 'Thursday': 'יום חמישי', 'Friday': 'יום שישי',
                'Saturday': 'שבת'
            };

            this.hebrewGregorianMonths = {
                1: 'ינואר', 2: 'פברואר', 3: 'מרץ', 4: 'אפריל', 5: 'מאי', 6: 'יוני',
                7: 'יולי', 8: 'אוגוסט', 9: 'ספטמבר', 10: 'אוקטובר', 11: 'נובמבר', 12: 'דצמבר'
            };

            // Hebrew book names mapping
            this.hebrewBookNames = {
                'Genesis': 'בראשית', 'Exodus': 'שמות', 'Leviticus': 'ויקרא', 'Numbers': 'במדבר',
                'Deuteronomy': 'דברים', 'Joshua': 'יהושע', 'Judges': 'שופטים',
                'I Samuel': 'שמואל א', 'II Samuel': 'שמואל ב',
                'I Kings': 'מלכים א', 'II Kings': 'מלכים ב', 'Isaiah': 'ישעיהו', 'Jeremiah': 'ירמיהו',
                'Ezekiel': 'יחזקאל', 'Hosea': 'הושע', 'Joel': 'יואל', 'Amos': 'עמוס', 'Obadiah': 'עובדיה',
                'Jonah': 'יונה', 'Micah': 'מיכה', 'Nahum': 'נחום', 'Habakkuk': 'חבקוק',
                'Zephaniah': 'צפניה', 'Haggai': 'חגי', 'Zechariah': 'זכריה', 'Malachi': 'מלאכי',
                'Psalms': 'תהלים', 'Proverbs': 'משלי', 'Job': 'איוב',
                'Song of Songs': 'שיר השירים', 'Ruth': 'רות', 'Lamentations': 'איכה',
                'Ecclesiastes': 'קהלת', 'Esther': 'אסתר', 'Daniel': 'דניאל', 'Ezra': 'עזרא',
                'Nehemiah': 'נחמיה', 'I Chronicles': 'דברי הימים א', 'II Chronicles': 'דברי הימים ב'
            };

            // Bible structure for generating verses
            this.bibleStructure = {
                'Genesis': 50, 'Exodus': 40, 'Leviticus': 27, 'Numbers': 36, 'Deuteronomy': 34,
                'Joshua': 24, 'Judges': 21, 'I Samuel': 31, 'II Samuel': 24, 'I Kings': 22,
                'II Kings': 25, 'Isaiah': 66, 'Jeremiah': 52, 'Ezekiel': 48, 'Hosea': 14,
                'Joel': 3, 'Amos': 9, 'Obadiah': 1, 'Jonah': 4, 'Micah': 7, 'Nahum': 3,
                'Habakkuk': 3, 'Zephaniah': 3, 'Haggai': 2, 'Zechariah': 14, 'Malachi': 4,
                'Psalms': 150, 'Proverbs': 31, 'Job': 42, 'Song of Songs': 8, 'Ruth': 4,
                'Lamentations': 5, 'Ecclesiastes': 12, 'Esther': 10, 'Daniel': 12,
                'Ezra': 10, 'Nehemiah': 13, 'I Chronicles': 29, 'II Chronicles': 36
            };

            this.verseCounts = {
                'Genesis': {1: 31, 2: 25, 3: 24, 4: 26, 5: 32, 6: 22, 7: 24, 8: 22, 9: 29, 10: 32},
                'Exodus': {1: 22, 2: 25, 3: 22, 4: 31, 5: 23, 6: 30, 7: 25, 8: 32, 9: 35, 10: 29}
            };
        }

        calculateHebrewBirthdays(birthDate) {
            const birth = new Date(birthDate);
            console.log('Calculating Hebrew birthdays for:', birth);
            
            // Try to use dynamically loaded Hebcal module first
            if (window.HebcalModule) {
                try {
                    console.log('Using Hebcal library for Hebrew date calculations');
                    const { HDate } = window.HebcalModule;
                    
                    // Create Hebrew date from Gregorian date
                    const hd = new HDate(birth);
                    console.log('Hebrew birth date:', hd.toString());
                    
                    // Get Hebrew birth date components
                    const hebrewBirthYear = hd.getFullYear();
                    const hebrewBirthMonth = hd.getMonth();
                    const hebrewBirthDay = hd.getDate();
                    
                    console.log(`Hebrew birth date: Year ${hebrewBirthYear}, Month ${hebrewBirthMonth}, Day ${hebrewBirthDay}`);
                    
                    // Calculate 5th Hebrew birthday
                    const fifthBirthdayHebrew = new HDate(hebrewBirthDay, hebrewBirthMonth, hebrewBirthYear + 5);
                    const startDate = fifthBirthdayHebrew.greg();
                    console.log('5th Hebrew birthday (Gregorian):', startDate);
                    
                    // Calculate 10th Hebrew birthday
                    const tenthBirthdayHebrew = new HDate(hebrewBirthDay, hebrewBirthMonth, hebrewBirthYear + 10);
                    const endDate = tenthBirthdayHebrew.greg();
                    
                    return { start: startDate, end: endDate };
                } catch (error) {
                    console.warn('Error using Hebcal library:', error);
                    // Fall through to use our simplified calculator
                }
            }
            
            // Fallback to our simplified calculator
            console.log('Falling back to simplified Hebrew date calculator');
            try {
                // Use our simplified Hebrew date calculator
                const hebrewBirthDate = hebrewCalculator.gregorianToHebrew(birth);
                console.log('Hebrew birth date:', hebrewBirthDate);
                
                // Calculate 5th Hebrew birthday
                const fifthHebrewBirthdayYear = hebrewBirthDate.year + 5;
                const startDate = hebrewCalculator.calculateHebrewBirthday(birth, fifthHebrewBirthdayYear);
                console.log('5th Hebrew birthday (Gregorian):', startDate);
                
                // Calculate 10th Hebrew birthday
                const tenthHebrewBirthdayYear = hebrewBirthDate.year + 10;
                const endDate = hebrewCalculator.calculateHebrewBirthday(birth, tenthHebrewBirthdayYear);
                console.log('10th Hebrew birthday (Gregorian):', endDate);
                
                console.log('Hebrew date calculation successful:', { start: startDate, end: endDate });
                return { start: startDate, end: endDate };
            } catch (error) {
                console.warn('Error with Hebcal calculations, using fallback:', error);
                const startDate = new Date(birth);
                startDate.setFullYear(birth.getFullYear() + 5);
                
                const endDate = new Date(birth);
                endDate.setFullYear(birth.getFullYear() + 10);
                
                return { start: startDate, end: endDate };
            }
        }

        buildBibleVerseList() {
            const verses = [];
            
            Object.entries(this.bibleStructure).forEach(([book, chapterCount]) => {
                for (let chapter = 1; chapter <= chapterCount; chapter++) {
                    const verseCount = this.verseCounts[book]?.[chapter] || this.estimateVerseCount(book, chapter);
                    
                    for (let verse = 1; verse <= verseCount; verse++) {
                        verses.push(`${book} ${chapter}:${verse}`);
                    }
                }
            });
            
            return verses;
        }

        estimateVerseCount(book, chapter) {
            if (['Psalms'].includes(book)) return Math.floor(Math.random() * 30) + 5;
            if (['Proverbs'].includes(book)) return Math.floor(Math.random() * 25) + 10;
            if (['Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy'].includes(book)) {
                return Math.floor(Math.random() * 40) + 15;
            }
            return Math.floor(Math.random() * 30) + 10;
        }

        isSaturday(date) {
            return date.getDay() === 6;
        }

        distributeVersesBalanced(verses, startDate, endDate, progressCallback) {
            const distributed = [];
            const currentDate = new Date(startDate);
            let remainingVerses = [...verses];
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
            let dayCount = 0;
            
            while (currentDate <= endDate && remainingVerses.length > 0) {
                const daysLeft = Math.ceil((endDate - currentDate) / (1000 * 60 * 60 * 24)) + 1;
                // Distribute verses evenly across all days
                const versesToday = Math.max(1, Math.ceil(remainingVerses.length / daysLeft));
                
                distributed.push(remainingVerses.splice(0, versesToday));
                currentDate.setDate(currentDate.getDate() + 1);
                dayCount++;
                
                if (progressCallback && dayCount % 50 === 0) {
                    progressCallback(20 + (dayCount / totalDays) * 60);
                }
            }
            
            return distributed;
        }

        async generateSchedule(childName, birthDate, progressCallback) {
            try {
                if (progressCallback) progressCallback(5, 'Calculating Hebrew dates...');
                
                const dateRange = this.calculateHebrewBirthdays(birthDate);
                
                if (progressCallback) progressCallback(15, 'Building Bible verse list...');
                
                const verses = this.buildBibleVerseList();
                
                if (progressCallback) progressCallback(20, 'Distributing verses across dates...');
                
                const distributedVerses = this.distributeVersesBalanced(
                    verses, 
                    dateRange.start, 
                    dateRange.end,
                    progressCallback
                );
                
                if (progressCallback) progressCallback(80, 'Building schedule...');
                
                const schedule = [];
                const currentDate = new Date(dateRange.start);
                
                for (let i = 0; i < distributedVerses.length && currentDate <= dateRange.end; i++) {
                    const dayVerses = distributedVerses[i];
                    let hd;
                    let hebrewDateFormatted;
                    
                    try {
                        // Try to use dynamically loaded Hebcal module first
                        if (window.HebcalModule) {
                            const { HDate } = window.HebcalModule;
                            const hd = new HDate(currentDate);
                            hebrewDateFormatted = hd.toString();
                        } else {
                            // Fallback to our simplified calculator
                            const hebrewDate = hebrewCalculator.gregorianToHebrew(currentDate);
                            hebrewDateFormatted = hebrewCalculator.formatHebrewDate(hebrewDate);
                        }
                    } catch (error) {
                        console.warn('Error formatting Hebrew date:', error);
                        hebrewDateFormatted = this.formatHebrewDateFallback(currentDate);
                    }
                    
                    schedule.push({
                        date: currentDate.toISOString().split('T')[0],
                        dayOfWeek: currentDate.toLocaleDateString('en-US', { weekday: 'long' }),
                        bible: dayVerses.join(', '),
                        bibleCount: dayVerses.length,
                        hebrewDay: this.hebrewDays[currentDate.toLocaleDateString('en-US', { weekday: 'long' })],
                        hebrewDate: hd,
                        hebrewDateFormatted: hebrewDateFormatted
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                    
                    if (progressCallback && i % 100 === 0) {
                        progressCallback(80 + (i / distributedVerses.length) * 15);
                    }
                }
                
                if (progressCallback) progressCallback(95, 'Finalizing...');
                
                return {
                    schedule,
                    totalVerses: verses.length,
                    totalDays: schedule.length,
                    startDate: dateRange.start,
                    endDate: dateRange.end
                };
                
            } catch (error) {
                console.error('Error generating schedule:', error);
                throw error;
            }
        }

        formatHebrewDate(date) {
            // Use our simplified Hebrew date calculator
            const hebrewDate = hebrewCalculator.gregorianToHebrew(date);
            return hebrewCalculator.formatHebrewDate(hebrewDate);
        }

        formatHebrewDateFallback(gregorianDate) {
            const day = gregorianDate.getDate();
            const month = gregorianDate.getMonth() + 1;
            const year = gregorianDate.getFullYear() + 3760;
            
            const monthMapping = {
                1: 'טבת', 2: 'שבט', 3: 'אדר', 4: 'ניסן', 5: 'אייר', 6: 'סיון',
                7: 'תמוז', 8: 'אב', 9: 'אלול', 10: 'תשרי', 11: 'חשון', 12: 'כסלו'
            };
            
            const hebrewMonth = monthMapping[month] || 'תשרי';
            return `${day} ${hebrewMonth} ${year}`;
        }

        // Convert numbers to Hebrew representation (gematria)
        hebrewNumber(num) {
            console.log(`Converting number ${num} to Hebrew representation`);
            if (!Number.isInteger(num) || num < 1) {
                return String(num);
            }

            const hebrewLetters = {
                1: 'א', 2: 'ב', 3: 'ג', 4: 'ד', 5: 'ה', 6: 'ו', 7: 'ז', 8: 'ח', 9: 'ט',
                10: 'י', 20: 'כ', 30: 'ל', 40: 'מ', 50: 'נ', 60: 'ס', 70: 'ע', 80: 'פ', 90: 'צ',
                100: 'ק', 200: 'ר', 300: 'ש', 400: 'ת'
            };
            
            // Special cases for 15 and 16 to avoid spelling God's name
            if (num === 15) return 'טו';
            if (num === 16) return 'טז';
            
            let result = '';
            let remaining = num;
            
            // Handle hundreds
            while (remaining >= 100) {
                if (remaining >= 400) {
                    result += hebrewLetters[400];
                    remaining -= 400;
                } else {
                    const hundreds = Math.floor(remaining / 100) * 100;
                    result += hebrewLetters[hundreds];
                    remaining %= 100;
                }
            }
            
            // Handle tens
            if (remaining >= 10) {
                const tens = Math.floor(remaining / 10) * 10;
                result += hebrewLetters[tens];
                remaining %= 10;
            }
            
            // Handle ones
            if (remaining > 0) {
                result += hebrewLetters[remaining];
            }
            
            return result;
        }
        
        formatGregorianDateHebrew(date) {
            const day = date.getDate();
            const hebrewDay = this.hebrewNumber(day); // Convert to Hebrew numerals
            const month = this.hebrewGregorianMonths[date.getMonth() + 1];
            const year = date.getFullYear();
            const hebrewYear = this.hebrewNumber(year + 3760); // Convert to Hebrew year and numerals
            
            return `${hebrewDay} ${month} ${hebrewYear}`;
        }

        scheduleToCSV(schedule) {
            const headers = ['Date', 'Day of Week', 'Hebrew Date', 'Bible', 'Bible Count'];
            const rows = [headers.join(',')];
            
            schedule.forEach(day => {
                const row = [
                    day.date,
                    day.dayOfWeek,
                    `"${day.hebrewDateFormatted}"`,
                    `"${day.bible}"`,
                    day.bibleCount
                ];
                rows.push(row.join(','));
            });
            
            return rows.join('\n');
        }

        async fetchHebrewVerses() {
            try {
                console.log('Fetching Hebrew verses from CSV...');
                
                // Try multiple path formats to find the CSV file
                const csvPaths = [
                    '/tanakh_verses_hebrew - tanakh_verses_hebrew.csv',
                    '/tanakh_verses_hebrew.csv',
                    '/public/tanakh_verses_hebrew - tanakh_verses_hebrew.csv',
                    '../public/tanakh_verses_hebrew - tanakh_verses_hebrew.csv'
                ];
                
                let response = null;
                
                // Try each path until we find one that works
                for (const path of csvPaths) {
                    try {
                        console.log(`Attempting to fetch from path: ${path}`);
                        response = await fetch(path);
                        
                        if (response.ok) {
                            console.log(`Successfully fetched from ${path}`);
                            break;
                        }
                    } catch (pathError) {
                        console.log(`Error fetching from ${path}:`, pathError.message);
                    }
                }
                
                if (!response || !response.ok) {
                    console.error('All paths failed, using hardcoded fallback data');
                    // Return a minimal hardcoded verses object with Genesis 1:1-3 as fallback
                    return {
                        'Genesis': {
                            1: {
                                1: 'בְּרֵאשִׁית בָּרָא אֱלֹהִים אֵת הַשָּׁמַיִם וְאֵת הָאָרֶץ׃',
                                2: 'וְהָאָרֶץ הָיְתָה תֹהוּ וָבֹהוּ וְחֹשֶׁךְ עַל־פְּנֵי תְהוֹם וְרוּחַ אֱלֹהִים מְרַחֶפֶת עַל־פְּנֵי הַמָּיִם׃',
                                3: 'וַיֹּאמֶר אֱלֹהִים יְהִי אוֹר וַיְהִי־אוֹר׃'
                            }
                        }
                    };
                }
                
                const text = await response.text();
                console.log(`Received CSV data length: ${text.length} characters`);
                
                if (text.length === 0) {
                    console.error('CSV file is empty!');
                    return {};
                }
                
                // Parse CSV data
                const lines = text.split('\n');
                console.log(`CSV has ${lines.length} lines`);
                
                // Create a structured object for easy access
                const verses = {};
                
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i] || lines[i].trim() === '') continue;
                    
                    const values = lines[i].split(',');
                    if (values.length >= 4) {
                        const book = values[0].trim();
                        const chapter = parseInt(values[1]);
                        const verse = parseInt(values[2]);
                        const text = values[3];
                        
                        // Create nested structure if not exists
                        if (!verses[book]) verses[book] = {};
                        if (!verses[book][chapter]) verses[book][chapter] = {};
                        
                        // Store verse text
                        verses[book][chapter][verse] = text;
                    }
                }
                
                return verses;
            } catch (error) {
                console.error('Critical error in fetchHebrewVerses:', error);
                return {}; // Return empty object as fallback
            }
        }
        
        // Get Hebrew verse text from the structured verses object
        getHebrewVerseText(verses, book, chapter, verse) {
            if (verses[book] && verses[book][chapter] && verses[book][chapter][verse]) {
                return verses[book][chapter][verse];
            }
            return null; // Verse not found
        }
        
        async generateBasicLaTeX(schedule, childName) {
    console.log('Starting enhanced LaTeX generation with proper Hebrew formatting...');

    // Fetch Hebrew verses
    const verses = await this.fetchHebrewVerses();
    console.log('Hebrew verses loaded for LaTeX generation');

    // Ensure childName is properly escaped for LaTeX if it can contain special characters
    // This is a basic escaping, more robust escaping might be needed depending on possible inputs.
    const latexChildName = childName.replace(/([&%$#_{}])/g, '\\$1').replace(/\\/g, '\\textbackslash{}');


    // LaTeX document content starts here
    let content = String.raw`%!TEX program = xelatex
% LaTeX Document - Hebrew Only
\documentclass[12pt, a4paper]{article}

% Hebrew Support
\usepackage{fontspec}
\usepackage{polyglossia}
\setmainlanguage{hebrew}
\setotherlanguage{english}

% Font Setup
\newfontfamily\hebrewfont[Script=Hebrew, Scale=1.2, Ligatures=TeX]{Ezra SIL}
\setmainfont[Script=Hebrew, Scale=1.0, Ligatures=TeX]{Ezra SIL}

% Ensure RTL direction
\TeXXeTstate=1
\setRTL

% Page Layout
\usepackage{geometry}
\geometry{
  a4paper,
  top=2cm,
  bottom=2cm,
  left=2.5cm,
  right=2.5cm,
  includeheadfoot
}

% Basic Packages
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{fancybox}
\usepackage{hyperref}

% Page Style
\pagestyle{plain}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    pdftitle={תוכנית לימוד תורה - ${latexChildName}},
    pdfauthor={${latexChildName}},
    unicode=true
}

% Section Formatting
\setcounter{secnumdepth}{0}
\makeatletter
\renewcommand{\@seccntformat}[1]{}
\renewcommand{\section}{%
  \@startsection{section}{1}{\z@}%
  {-3.5ex \@plus -1ex \@minus -.2ex}%
  {2.3ex \@plus.2ex}%
  {\normalfont\Large\bfseries}}%
\renewcommand{\subsection}{%
  \@startsection{subsection}{2}{\z@}%
  {-3.25ex\@plus -1ex \@minus -.2ex}%
  {1.5ex \@plus .2ex}%
  {\normalfont\large\bfseries}}%
\makeatother

% Custom Commands
\newcommand{\hebfont}[1]{\texthebrew{#1}}
\newcommand{\enfont}[1]{\textenglish{#1}}
\newcommand{\hebsection}[1]{%
  \par\vspace{1em}\noindent
  \fbox{%
    \begin{minipage}{\dimexpr\textwidth-2\fboxsep-2\fboxrule\relax}
      \centering\large\bfseries #1%
    \end{minipage}%
  }%
  \par\vspace{0.5em}%
}

% Document Begins
\begin{document}

% Title Page
\begin{center}
  \vspace*{2cm}
  {\LARGE\bfseries תוכנית לימוד תורה}
  \vspace{1cm}
  
  {\large ל${latexChildName}}
  \vspace{2cm}
  
  {\large תאריך יצירה: \today}
\end{center}

\vspace{2cm}
\begin{center}
  תוכן העניינים
\end{center}
\tableofcontents
\newpage
\setcounter{page}{1}

`; // End of preamble and initial setup string literal

    // Process each day in the schedule
    for (let index = 0; index < schedule.length; index++) {
        const day = schedule[index];
        if (!day || !day.date) {
            console.warn(`Skipping day at index ${index} due to missing day or date.`);
            continue;
        }
        
        try {
            const date = new Date(day.date);
            
            // Format Hebrew date with numeric year
            const hebrewDate = new Intl.DateTimeFormat('he-IL-u-ca-hebrew', {
                day: 'numeric',
                month: 'long',
                year: 'numeric',
                numberingSystem: 'hebr' // Use Hebrew numerals for day/month
            }).format(date);
            
            // Split the formatted date to extract just the Hebrew month and day
            const hebrewParts = hebrewDate.split(' ');
            const hebrewDay = hebrewParts[0];
            const hebrewMonth = hebrewParts[1];
            const hebrewYear = date.getFullYear();
            
            // Format Gregorian date with Hebrew month names
            const gregorianDay = date.getDate();
            const gregorianMonth = date.toLocaleString('he-IL', { month: 'long' });
            const gregorianYear = date.getFullYear();
            
            // Create formatted date strings
            const hebrewFormatted = `${hebrewDay} ${hebrewMonth} ${hebrewYear}`;
            const gregorianFormatted = `${gregorianDay} ${gregorianMonth} ${gregorianYear}`;
            
            // Get Hebrew day name if not provided
            const hebrewDayName = day.hebrewDay || new Intl.DateTimeFormat('he-IL', { weekday: 'long' }).format(date);
            
            // Enhanced LaTeX escaping that handles Hebrew text properly
            const escapeLatex = (str) => {
                if (!str) return '';
                // First escape backslashes, then other special chars
                return String(str)
                    .replace(/\\/g, '\\\\')
                    .replace(/[&%$#_{}]/g, '\\\\$&')
                    .replace(/~/g, '\\\\textasciitilde ')
                    .replace(/\^/g, '\\\\textasciicircum ')
                    .replace(/\n/g, ' ')
                    // Remove any remaining control characters
                    .replace(/[\x00-\x1F\x7F-\x9F]/g, '');
            };
            
            const escapedHebrewDayName = escapeLatex(hebrewDayName);
            const escapedHebrewDate = escapeLatex(hebrewFormatted);
            const escapedGregorianDate = escapeLatex(gregorianFormatted);
            
            const dayTitleForToC = `${escapedHebrewDayName}, ${escapedHebrewDate} (${escapedGregorianDate})`;
            const sectionDisplayTitle = dayTitleForToC;

            // Build content in parts to avoid template literal issues
            content += '\n% ===== Start of content =====\n' +
                     '\\hebsection{' + sectionDisplayTitle + '}\n' +
                     '\\phantomsection\n' +
                     '\\section*{' + dayTitleForToC + '}\n' +
                     '\\addcontentsline{toc}{section}{' + dayTitleForToC + '}\n\n' +
                     '% Date display in Hebrew\n' +
                     '\\begin{center}\n' +
                     '  \\large\\bfseries\n' +
                     '  ' + escapedHebrewDayName + '\\\\\n' +
                     '  \\medskip\n' +
                     '  ' + escapedHebrewDate + '\\\\\n' +
                     '  \\small(' + escapedGregorianDate + ')\n' +
                     '\\end{center}\n' +
                     '\\vspace{1em}\n';

            if (day.bible) {
                const refs = day.bible.split(',').map(s => s.trim()).filter(s => s); // Trim and filter empty strings
                const groupedRefs = {}; // { hebrewBookDisplay: { englishName: "Genesis", chapters: { 1: [1,2,3], 2: [4,5] } } }
                
                refs.forEach(ref => {
                    const parts = ref.split(' ');
                    if (parts.length >= 2 && parts[parts.length - 1].includes(':')) {
                        const bookNameEng = parts.slice(0, -1).join(' ');
                        const [chapterStr, verseRangeStr] = parts[parts.length - 1].split(':');
                        const chapterNum = parseInt(chapterStr);

                        const hebrewBookDisplay = (this.hebrewBookNames && this.hebrewBookNames[bookNameEng]) 
                                                  ? this.hebrewBookNames[bookNameEng] 
                                                  : bookNameEng; 
                        
                        if (!groupedRefs[hebrewBookDisplay]) {
                            groupedRefs[hebrewBookDisplay] = { englishName: bookNameEng, chapters: {} };
                        }
                        if (!groupedRefs[hebrewBookDisplay].chapters[chapterNum]) {
                            groupedRefs[hebrewBookDisplay].chapters[chapterNum] = [];
                        }
                        
                        // Handle verse ranges (e.g., 1-5) or single verses
                        if (verseRangeStr.includes('-')) {
                            const [start, end] = verseRangeStr.split('-').map(v => parseInt(v));
                            if (!isNaN(start) && !isNaN(end)) {
                                for (let v = start; v <= end; v++) {
                                    groupedRefs[hebrewBookDisplay].chapters[chapterNum].push(v);
                                }
                            }
                        } else {
                            const verseNum = parseInt(verseRangeStr);
                            if(!isNaN(verseNum)) {
                                groupedRefs[hebrewBookDisplay].chapters[chapterNum].push(verseNum);
                            }
                        }
                    } else {
                        console.warn(`Could not parse Bible reference: ${ref}`);
                    }
                });
                
                for (const hebrewBookKey in groupedRefs) {
                    const bookData = groupedRefs[hebrewBookKey];
                    let englishBookForVerseLookup = bookData.englishName;

                    content += `
\vspace{0.5em}
\begin{minipage}{\linewidth}
  \begin{raggedright}
    {\large\bfseries ${hebrewBookKey}}
    \vspace{0.3em}
    \hrule height 0.5pt
    \vspace{0.5em}
  \end{raggedright}
\end{minipage}
`;
                    for (const chapterKey in bookData.chapters) {
                        const chapterNum = parseInt(chapterKey);
                        const hebrewChapterNum = (this.hebrewNumber && typeof this.hebrewNumber === 'function') 
                                                 ? this.hebrewNumber(chapterNum) 
                                                 : chapterNum.toString();

                        content += `
\vspace{0.5em}
\begin{minipage}{\linewidth}
  \begin{raggedright}
    {\bfseries פרק ${hebrewChapterNum}}
    \vspace{0.3em}
  \end{raggedright}
\end{minipage}

% Verse list with proper RTL support
\begin{enumerate}[label={}, 
                 rightmargin=0pt, 
                 leftmargin=3.5em, 
                 itemsep=0.2em, 
                 topsep=0.2em, 
                 parsep=0.2em, 
                 widest={}]
`;
                        // Normalize book name for verse lookup using your map
                        // Ensure this.bookNameMap is defined and accessible, or pass it as an argument
                        const bookNameMap = (this.bookNameMap && typeof this.bookNameMap === 'object') ? this.bookNameMap : {
                            // Default minimal map or ensure it's passed/available
                            'Genesis': 'Genesis', 'Exodus': 'Exodus', /* ... add more essential mappings ... */
                        };
                        englishBookForVerseLookup = bookNameMap[englishBookForVerseLookup] || englishBookForVerseLookup;

                        const verseList = [...new Set(bookData.chapters[chapterNum])].sort((a, b) => a - b); // Unique sorted verses

                        if (!verses || Object.keys(verses).length === 0 || !verses[englishBookForVerseLookup] || !verses[englishBookForVerseLookup][chapterNum.toString()]) {
                            console.warn(`No verses data for book: ${englishBookForVerseLookup}, chapter: ${chapterNum}`);
                            verseList.forEach(verseNum => {
                                const hebrewVerseNum = (this.hebrewNumber && typeof this.hebrewNumber === 'function') ? this.hebrewNumber(verseNum) : verseNum.toString();
                                content += `  \item[${hebrewVerseNum}] טקסט הפסוק (${englishBookForVerseLookup} ${chapterNum}:${verseNum}) לא זמין\
`;
                            });
                        } else {
                            for (const verseNum of verseList) {
                                let verseText = `[${englishBookForVerseLookup} ${chapterNum}:${verseNum} - טקסט לא זמין]`; // Default
                                try {
                                    if (this.getHebrewVerseText && typeof this.getHebrewVerseText === 'function') {
                                        verseText = this.getHebrewVerseText(
                                            verses, 
                                            englishBookForVerseLookup, 
                                            chapterNum.toString(),
                                            verseNum.toString()
                                        );
                                    }
                                    if (!verseText || verseText.trim() === '') {
                                        verseText = `[${englishBookForVerseLookup} ${chapterNum}:${verseNum} - טקסט הפסוק חסר]`;
                                    }
                                } catch (e) {
                                    console.error(`Error in getHebrewVerseText for ${englishBookForVerseLookup} ${chapterNum}:${verseNum}:`, e);
                                    const hebrewVerseNumForError = (this.hebrewNumber && typeof this.hebrewNumber === 'function') ? this.hebrewNumber(verseNum) : verseNum.toString();
                                    verseText = `\\textcolor{red}{שגיאה בטעינת פסוק ${hebrewVerseNumForError}}`;
                                }
                                const hebrewVerseLabel = (this.hebrewNumber && typeof this.hebrewNumber === 'function') ? this.hebrewNumber(verseNum) : verseNum.toString();
                                content += `  \item[${hebrewVerseLabel}] ${verseText}\
`;
                            }
                        }
                        content += '\\end{enumerate}\n';
                    }
                }
            }
            
            if (index < schedule.length - 1) {
                content += '\\newpage\n';
            }
        } catch (error) {
            console.error(`Error processing day ${index} (Date: ${day.date || 'N/A'}):`, error);
            content += `
\\newpage % Ensure error message is on a new page
\\begin{center}
  \\hebfont{\\Large\\bfseries שגיאה בעיבוד היום}
\\end{center}
\\hebfont{אירעה שגיאה בעיבוד הנתונים עבור יום זה (${day.date || 'תאריך לא זמין'}). אנא בדוק את הנתונים או פנה לתמיכה.}
\\newpage\n`;
        }
    }

    // Closing part of the document
    content += `
\vfill
\begin{center}
  {\large\bfseries בהצלחה בלימוד התורה הקדושה!}
  \\[1ex]
  שנזכה ללמוד וללמד, לשמור ולעשות
  \\
  את כל דברי תלמוד תורתך באהבה.
  \\[2ex]
  בברכה,
  \\[1ex]
  צוות המערכת
\end{center}
\vspace{2em}
\end{document}
`;
    console.log('Enhanced LaTeX content generated.');
    return content;
}

        generateICS(schedule, childName) {
            const icsLines = [];
            icsLines.push("BEGIN:VCALENDAR");
            icsLines.push("VERSION:2.0");
            icsLines.push("PRODID:-//Torah Study Schedule//EN");
            
            schedule.forEach((day, index) => {
                const dt = new Date(day.date);
                const dtstart = dt.toISOString().replace(/[-:]/g, '').split('T')[0];
                const summary = `${childName} Torah Study`;
                const description = `Hebrew Date: ${day.hebrewDateFormatted}\\nLearn: ${day.bible}`;
                
                icsLines.push("BEGIN:VEVENT");
                icsLines.push(`UID:${childName}_${dtstart}_${index}@torah_study`);
                icsLines.push(`DTSTART;VALUE=DATE:${dtstart}`);
                icsLines.push(`SUMMARY:${summary}`);
                icsLines.push(`DESCRIPTION:${description}`);
                icsLines.push("END:VEVENT");
            });
            
            icsLines.push("END:VCALENDAR");
            return icsLines.join('\n');
        }
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
        // Try to wait for Hebcal module to load
        function waitForHebcal(maxAttempts = 10) {
            if (window.HebcalModule) {
                console.log('Hebcal module is available, initializing Torah Schedule Generator');
                initializeApp();
                return;
            }
            
            if (maxAttempts <= 0) {
                console.warn('Hebcal module did not load in time, initializing with fallback');
                initializeApp();
                return;
            }
            
            console.log(`Waiting for Hebcal module to load... (${maxAttempts} attempts left)`);
            setTimeout(() => waitForHebcal(maxAttempts - 1), 100);
        }
        
        // Start waiting for Hebcal
        waitForHebcal();
        
        // Define initialization function
        function initializeApp() {
            // Check for dynamically loaded Hebcal module
            console.log('Checking for Hebcal module:', window.HebcalModule ? 'Available' : 'Not yet available');
            
            // Initialize the generator
            console.log('Initializing Torah Schedule Generator...');
            
            const generator = new TorahScheduleGenerator();
            let currentScheduleData = null;

            const form = document.getElementById('scheduleForm');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const results = document.getElementById('results');
            const preview = document.getElementById('preview');

            function updateProgress(percent, text) {
                progressBar.style.width = `${percent}%`;
                progressText.textContent = text;
            }

            function showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                form.appendChild(errorDiv);
                setTimeout(() => errorDiv.remove(), 5000);
            }

            function downloadFile(content, filename, contentType) {
                const blob = new Blob([content], { type: contentType });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }

            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const childName = document.getElementById('childName').value;
                const birthDate = document.getElementById('birthDate').value;
                
                const generateBtn = document.getElementById('generateBtn');
                generateBtn.disabled = true;
                generateBtn.textContent = 'Generating...';
                
                progressContainer.classList.remove('hidden');
                results.classList.add('hidden');
                
                try {
                    currentScheduleData = await generator.generateSchedule(
                        childName,
                        birthDate,
                        updateProgress
                    );
                    
                    updateProgress(100, 'Complete!');
                    
                    const previewText = `Schedule generated successfully!
Total verses: ${currentScheduleData.totalVerses}
Total days: ${currentScheduleData.totalDays}
Start date: ${currentScheduleData.startDate.toDateString()}
End date: ${currentScheduleData.endDate.toDateString()}

First 5 days:
${currentScheduleData.schedule.slice(0, 5).map((day, i) => 
  `${i + 1}. ${day.date} (${day.dayOfWeek}): ${day.hebrewDateFormatted} - ${day.bibleCount} verses`
).join('\n')}`;
                    
                    preview.textContent = previewText;
                    results.classList.remove('hidden');
                    
                    document.getElementById('downloadCSV').onclick = () => {
                        const csv = generator.scheduleToCSV(currentScheduleData.schedule);
                        downloadFile(csv, `torah_schedule_${childName.replace(/\s+/g, '_')}_${birthDate}.csv`, 'text/csv');
                    };
                    
                    document.getElementById('downloadLaTeX').onclick = async () => {
                        try {
                            updateProgress(0, 'Generating LaTeX with Hebrew formatting...');
                            progressContainer.classList.remove('hidden');
                            
                            const latex = await generator.generateBasicLaTeX(currentScheduleData.schedule, childName);
                            downloadFile(latex, `torah_schedule_${childName.replace(/\s+/g, '_')}_${birthDate}.tex`, 'text/plain');
                            
                            updateProgress(100, 'LaTeX generated successfully!');
                            setTimeout(() => progressContainer.classList.add('hidden'), 2000);
                        } catch (error) {
                            console.error('Error generating LaTeX:', error);
                            showError(`Error generating LaTeX: ${error.message}`);
                            progressContainer.classList.add('hidden');
                        }
                    };
                    
                    document.getElementById('downloadICS').onclick = () => {
                        const ics = generator.generateICS(currentScheduleData.schedule, childName);
                        downloadFile(ics, `torah_schedule_${childName.replace(/\s+/g, '_')}_${birthDate}.ics`, 'text/calendar');
                    };
                    
                } catch (error) {
                    console.error('Error:', error);
                    showError(`Error generating schedule: ${error.message}`);
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Schedule';
                    setTimeout(() => {
                        progressContainer.classList.add('hidden');
                    }, 2000);
                }
            });
        }
        // Call the initialization function
        initializeApp();
    });
</script>